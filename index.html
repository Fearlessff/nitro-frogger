!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nitro Frog OG - Enhanced Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto:wght@300;400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .screen-shake {
            animation: screenShake 0.5s ease-in-out;
        }

        @keyframes screenShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        #nameInput {
            margin: 20px 0;
        }

        #nameInput input {
            font-family: 'Orbitron', monospace;
            padding: 12px 20px;
            border-radius: 25px;
            border: 2px solid #00ffcc;
            background: rgba(26, 47, 74, 0.9);
            color: white;
            font-size: 16px;
            margin-right: 10px;
            backdrop-filter: blur(10px);
        }

        #nameInput input:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.5);
        }

        body {
            background: linear-gradient(135deg, #0a0a23, #1a1a3a, #2d1b4e);
            font-family: 'Roboto', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 200, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 120, 200, 0.1) 0%, transparent 50%);
            z-index: -1;
            animation: backgroundPulse 4s ease-in-out infinite alternate;
        }

        @keyframes backgroundPulse {
            from { opacity: 0.3; }
            to { opacity: 0.7; }
        }

        #gameContainer {
            position: relative;
            max-width: 700px;
            width: 100%;
            filter: drop-shadow(0 20px 40px rgba(0, 255, 204, 0.3));
        }

        #gameCanvas {
            width: 100%;
            max-width: 700px;
            height: 900px;
            background: linear-gradient(180deg, #87CEEB 0%, #4682B4 20%, #2F4F4F 100%);
            border: 6px solid transparent;
            border-radius: 20px;
            background-clip: padding-box;
            position: relative;
            animation: canvasGlow 3s ease-in-out infinite alternate;
        }

        #gameCanvas::before {
            content: '';
            position: absolute;
            top: -6px;
            left: -6px;
            right: -6px;
            bottom: -6px;
            background: linear-gradient(45deg, #00ffcc, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7);
            border-radius: 26px;
            z-index: -1;
            animation: borderRotate 3s linear infinite;
        }

        @keyframes canvasGlow {
            from { filter: brightness(1) saturate(1); }
            to { filter: brightness(1.1) saturate(1.2); }
        }

        @keyframes borderRotate {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            text-align: center;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            background: rgba(0, 31, 47, 0.95);
        }

        #startScreen, #gameOverScreen, #pauseScreen, #achievementScreen {
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #pauseScreen, #achievementScreen {
            display: none;
        }

        .logo {
            width: 150px;
            height: 150px;
            margin-bottom: 30px;
            filter: drop-shadow(0 10px 20px rgba(0, 255, 204, 0.5));
            animation: logoFloat 3s ease-in-out infinite;
        }

        @keyframes logoFloat {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }

        h1 {
            font-family: 'Orbitron', monospace;
            font-size: 42px;
            margin: 20px 0;
            background: linear-gradient(45deg, #00ffcc, #ff6b6b, #4ecdc4);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(0, 255, 204, 0.5);
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .subtitle {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 30px;
            font-weight: 300;
        }

        p {
            max-width: 450px;
            font-size: 16px;
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        .game-button {
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            font-weight: 700;
            padding: 18px 36px;
            background: linear-gradient(45deg, #00ffcc, #4ecdc4);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin: 8px;
            color: #0a0a23;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .game-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 255, 204, 0.4);
            background: linear-gradient(45deg, #4ecdc4, #00ffcc);
        }

        .game-button:active {
            transform: translateY(-1px);
        }

        .game-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .game-button:hover::before {
            left: 100%;
        }

        .stats-container {
            position: absolute;
            top: 25px;
            left: 25px;
            right: 25px;
            display: flex;
            justify-content: space-between;
            z-index: 100;
        }

        .stat-item {
            background: rgba(0, 31, 47, 0.9);
            padding: 15px 25px;
            border-radius: 25px;
            color: white;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 18px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 204, 0.3);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .stat-value {
            color: #00ffcc;
            margin-left: 8px;
        }

        #powerUpIndicator {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, #ff6b6b, #ffa500);
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            z-index: 150;
            display: none;
            animation: powerUpGlow 1s ease-in-out infinite alternate;
        }

        @keyframes powerUpGlow {
            from { box-shadow: 0 0 10px rgba(255, 107, 107, 0.5); }
            to { box-shadow: 0 0 25px rgba(255, 107, 107, 0.9); }
        }

        .combo-display {
            position: absolute;
            top: 150px;
            right: 25px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            padding: 10px 15px;
            border-radius: 15px;
            color: white;
            font-weight: bold;
            z-index: 120;
            display: none;
            animation: comboShake 0.2s ease-in-out;
        }

        @keyframes comboShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        #levelSelect {
            margin: 25px 0;
            background: rgba(0, 31, 47, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 204, 0.3);
        }

        #levelSelect select {
            font-family: 'Orbitron', monospace;
            font-size: 16px;
            padding: 12px 20px;
            border-radius: 25px;
            border: 2px solid #00ffcc;
            background: #1a2f4a;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #levelSelect select:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.5);
        }

        #leaderboard {
            background: rgba(26, 47, 74, 0.9);
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            max-width: 400px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 204, 0.3);
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .leaderboard-entry:hover {
            background: rgba(0, 255, 204, 0.1);
            padding-left: 10px;
        }

        .achievement-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 20px 0;
            max-width: 400px;
        }

        .achievement-item {
            background: rgba(26, 47, 74, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 204, 0.3);
            text-align: center;
            transition: all 0.3s ease;
        }

        .achievement-item.unlocked {
            background: linear-gradient(45deg, #00ffcc, #4ecdc4);
            color: #0a0a23;
            transform: scale(1.05);
        }

        .creator {
            margin-top: 40px;
            font-size: 14px;
            color: #666;
            font-style: italic;
        }

        #levelUpMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', monospace;
            font-size: 64px;
            font-weight: 900;
            z-index: 2000;
            display: none;
            text-shadow: 0 0 30px rgba(0, 255, 204, 0.8);
            animation: levelUpAnim 3s ease-out;
        }

        @keyframes levelUpAnim {
            0% { 
                transform: translate(-50%, -50%) scale(0) rotate(-180deg); 
                opacity: 0;
                background: linear-gradient(45deg, #ff6b6b, #ffa500);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.3) rotate(0deg); 
                opacity: 1;
            }
            100% { 
                transform: translate(-50%, -50%) scale(1) rotate(0deg); 
                opacity: 0;
                background: linear-gradient(45deg, #00ffcc, #4ecdc4);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
            }
        }

        .controls-help {
            position: absolute;
            bottom: 200px; /* Moved much higher for mobile */
            left: 50%;
            transform: translateX(-50%);
            color: #aaa;
            font-size: 14px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 16px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 204, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .control-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 12px;
            width: 220px;
            height: 220px;
        }

        .control-btn {
            background: linear-gradient(45deg, rgba(0, 255, 204, 0.9), rgba(78, 205, 196, 0.9));
            border: none;
            border-radius: 20px;
            font-size: 28px;
            color: #0a0a23;
            font-weight: bold;
            touch-action: manipulation;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .control-btn:active {
            transform: scale(0.85);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
            background: linear-gradient(45deg, rgba(78, 205, 196, 1), rgba(0, 255, 204, 1));
        }

        .control-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.3s;
        }

        .control-btn:active::before {
            left: 100%;
        }

        .control-btn.up { 
            grid-column: 2; 
            grid-row: 1; 
            background: linear-gradient(45deg, rgba(78, 205, 196, 0.9), rgba(0, 255, 204, 0.9));
        }
        
        .control-btn.left { 
            grid-column: 1; 
            grid-row: 2; 
            background: linear-gradient(45deg, rgba(78, 205, 196, 0.9), rgba(0, 255, 204, 0.9));
        }
        
        .control-btn.pause { 
            grid-column: 2; 
            grid-row: 2; 
            background: linear-gradient(45deg, rgba(255, 107, 107, 0.9), rgba(255, 165, 0, 0.9));
            font-size: 24px;
        }
        
        .control-btn.right { 
            grid-column: 3; 
            grid-row: 2; 
            background: linear-gradient(45deg, rgba(78, 205, 196, 0.9), rgba(0, 255, 204, 0.9));
        }
        
        .control-btn.down { 
            grid-column: 2; 
            grid-row: 3; 
            background: linear-gradient(45deg, rgba(78, 205, 196, 0.9), rgba(0, 255, 204, 0.9));
        }

        @media (max-width: 768px) {

            
            .controls-help {
                display: none;
            }

            h1 {
                font-size: 28px;
            }

            .stats-container {
                top: 10px;
                left: 10px;
                right: 10px;
            }

            .stat-item {
                padding: 8px 12px;
                font-size: 12px;
            }

            #gameCanvas {
                height: 100vh; /* Full height on mobile */
                max-height: none;
            }

            #gameContainer {
                height: 100vh;
                max-width: 100vw;
            }

            .control-grid {
                width: 200px;
                height: 200px;
                gap: 10px;
            }

            .control-btn {
                font-size: 24px;
            }
        }

        @media (max-width: 480px) {
            .control-grid {
                width: 180px;
                height: 180px;
                gap: 8px;
            }

            .control-btn {
                font-size: 20px;
                border-radius: 15px;
            }

            .stats-container {
                top: 5px;
                left: 5px;
                right: 5px;
            }

            .stat-item {
                padding: 6px 10px;
                font-size: 11px;
            }
        }

        /* Particle effects for UI */
        .floating-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #00ffcc;
            border-radius: 50%;
            animation: floatUp 3s linear infinite;
            z-index: -1;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(100vh) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) rotate(360deg);
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="700" height="900"></canvas>
        
        <div class="stats-container">
            <div class="stat-item">
                Score: <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat-item">
                Level: <span class="stat-value" id="levelDisplay">1</span>
            </div>
            <div class="stat-item">
                Lives: <span class="stat-value" id="lives">3</span>
            </div>
        </div>

        <div id="powerUpIndicator">⚡ INVINCIBLE!</div>
        <div id="comboDisplay" class="combo-display">COMBO x<span id="comboCount">0</span>!</div>
        
        <div id="startScreen" class="screen">
            <img class="logo" src="assets/frog.png" alt="Nitro Frog Logo">
            <h1>NITRO FROG OG</h1>
            <p class="subtitle">Enhanced Edition</p>
            <p><strong>🎮 How to Play:</strong><br>
            Guide the fearless frog across deadly traffic lanes! Collect power-ups, 
            build combos, and unlock achievements. Each successful crossing increases 
            your score and unlocks new challenges!</p>
            
            <div id="levelSelect">
                <label for="difficulty">⚡ Choose Your Challenge:</label><br>
                <select id="difficulty">
                    <option value="easy">🟢 Rookie Hopper</option>
                    <option value="medium" selected>🟡 Street Veteran</option>
                    <option value="hard">🔴 Road Warrior</option>
                    <option value="insane">💀 Death Wish</option>
                </select>
            </div>
            
            <button class="game-button" onclick="startGame()">🚀 START ADVENTURE</button>
            <button class="game-button" onclick="showLeaderboard()">🏆 HALL OF FAME</button>
            <button class="game-button" onclick="showAchievements()">🎖️ ACHIEVEMENTS</button>
            
            <div class="creator">Created with 💚 by FEARLESS</div>
        </div>

        <div id="gameOverScreen" class="screen" style="display:none;">
            <img class="logo" src="assets/frog.png" alt="Nitro Frog Logo">
            <h1>GAME OVER!</h1>
            <p>💥 Your brave frog has been flattened! But legends never die...</p>
            
            <div style="margin: 25px 0; font-family: 'Orbitron', monospace;">
                <div style="font-size: 24px;">Final Score: <span style="color: #00ffcc;" id="finalScore">0</span></div>
                <div style="font-size: 18px; margin-top: 10px;">High Score: <span style="color: #ffa500;" id="highScore">0</span></div>
                <div style="font-size: 16px; margin-top: 5px;">Level Reached: <span style="color: #ff6b6b;" id="finalLevel">1</span></div>
            </div>
            
            <div id="nameInput">
                <input type="text" id="playerName" placeholder="Enter your legend name" maxlength="15">
                <button class="game-button" onclick="submitScore()">🎯 SUBMIT</button>
            </div>
            
            <div id="leaderboard"></div>
            
            <button class="game-button" onclick="restartGame()">🔄 PLAY AGAIN</button>
            <button class="game-button" onclick="goToMenu()">🏠 MAIN MENU</button>
        </div>

        <div id="pauseScreen" class="screen">
            <h1>⏸️ PAUSED</h1>
            <p>Take a breath, the roads will wait...</p>
            <button class="game-button" onclick="resumeGame()">▶️ RESUME</button>
            <button class="game-button" onclick="goToMenu()">🏠 MAIN MENU</button>
        </div>

        <div id="achievementScreen" class="screen">
            <h1>🎖️ ACHIEVEMENTS</h1>
            <div id="achievementGrid" class="achievement-grid"></div>
            <button class="game-button" onclick="goToMenu()">🏠 BACK</button>
        </div>

        <div id="levelUpMessage">LEVEL UP!</div>

        <div class="controls-help">
            <p>🎮 Arrow Keys: Move | SPACE: Pause | ESC: Menu</p>
        </div>

    </div>

    <!-- Audio Elements -->
    <audio id="jumpSound" preload="auto">
        <source src="assets/jump.mp3" type="audio/mpeg">
    </audio>
    <audio id="crashSound" preload="auto">
        <source src="assets/crash.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = 'menu';
        let score = 0;
        let lives = 3;
        let level = 1;
        let difficulty = 'medium';
        let highScore = localStorage.getItem('nitroFrogHighScore') || 0;
        let combo = 0;
        let isInvincible = false;
        let invincibilityTimer = 0;
        
        // Game objects
        let player;
        let cars = [];
        let particles = [];
        let powerUps = [];
        let floatingTexts = [];
        
        // Images
        const images = {};
        const imageFiles = ['assets/frog.png', 'assets/car1.png', 'assets/car2.png', 'assets/car3.png', 'assets/car4.png'];
        let imagesLoaded = 0;
        
        // Audio
        const jumpSound = document.getElementById('jumpSound');
        const crashSound = document.getElementById('crashSound');
        
        // Game settings - Redesigned layout
        const CELL_SIZE = 60;
        const ROAD_LANES = [200, 260, 320, 380, 440, 500, 560, 620]; // 8 lanes moved up
        const SAFE_ZONES = [80, 160, 680, 750]; // Top and bottom safe zones
        const FINISH_LINE = 100; // Goal area at top
        
        // Enhanced difficulty settings
        const DIFFICULTY_SETTINGS = {
            easy: { carSpeed: 1.5, carSpawnRate: 0.12, maxCars: 8, powerUpChance: 0.08 },
            medium: { carSpeed: 2.5, carSpawnRate: 0.18, maxCars: 12, powerUpChance: 0.06 },
            hard: { carSpeed: 3.5, carSpawnRate: 0.25, maxCars: 16, powerUpChance: 0.04 },
            insane: { carSpeed: 5, carSpawnRate: 0.35, maxCars: 20, powerUpChance: 0.02 }
        };

        // Achievements system
        const achievements = {
            firstStep: { name: 'First Hop', desc: 'Move for the first time', unlocked: false },
            scorer: { name: 'Point Collector', desc: 'Score 100 points', unlocked: false },
            survivor: { name: 'Survivor', desc: 'Reach level 5', unlocked: false },
            comboMaster: { name: 'Combo Master', desc: 'Get a 5x combo', unlocked: false },
            powerUser: { name: 'Power User', desc: 'Collect 10 power-ups', unlocked: false },
            roadWarrior: { name: 'Road Warrior', desc: 'Score 1000 points', unlocked: false },
            invincible: { name: 'Untouchable', desc: 'Complete a level without getting hit', unlocked: false },
            speedDemon: { name: 'Speed Demon', desc: 'Complete 3 levels in under 30 seconds', unlocked: false }
        };

        let gameStats = {
            powerUpsCollected: 0,
            levelsCompleted: 0,
            gameStartTime: 0,
            hitsTaken: 0
        };

        // Enhanced Player class
        class Player {
            constructor() {
                this.x = canvas.width / 2 - 30;
                this.y = canvas.height - 180; // Start much higher up for mobile
                this.width = 60;
                this.height = 60;
                this.lastY = this.y;
                this.isMoving = false;
                this.moveAnimation = 0;
                this.rotation = 0;
                this.scale = 1;
            }
            
            draw() {
                ctx.save();
                
                // Apply transformations
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                ctx.translate(centerX, centerY);
                ctx.rotate(this.rotation);
                ctx.scale(this.scale, this.scale);
                
                // Add glow effect if invincible
                if (isInvincible) {
                    const time = Date.now() * 0.01;
                    ctx.shadowColor = `hsl(${time % 360}, 100%, 50%)`;
                    ctx.shadowBlur = 20;
                }
                
                if (images['assets/frog.png']) {
                    ctx.drawImage(images['assets/frog.png'], -this.width/2, -this.height/2, this.width, this.height);
                } else {
                    // Enhanced fallback
                    ctx.fillStyle = isInvincible ? `hsl(${Date.now() * 0.1 % 360}, 100%, 50%)` : '#00ff00';
                    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                    
                    // Draw eyes
                    ctx.fillStyle = '#000';
                    ctx.fillRect(-this.width/2 + 10, -this.height/2 + 10, 12, 12);
                    ctx.fillRect(-this.width/2 + 30, -this.height/2 + 10, 12, 12);
                    
                    // Draw mouth
                    ctx.beginPath();
                    ctx.arc(0, this.height/4, 15, 0, Math.PI);
                    ctx.stroke();
                }
                
                ctx.restore();
                
                // Update animations
                if (this.isMoving) {
                    this.moveAnimation -= 0.1;
                    if (this.moveAnimation <= 0) {
                        this.isMoving = false;
                    }
                }
                
                this.rotation *= 0.9;
                this.scale = Math.max(1, this.scale * 0.95);
            }
            
            move(direction) {
                if (gameState !== 'playing') return;
                
                const prevY = this.y;
                let moved = false;
                
                switch(direction) {
                    case 'up':
                        if (this.y > 50) {
                            this.y -= CELL_SIZE;
                            this.rotation = -0.2;
                            moved = true;
                            
                            if (this.y < this.lastY) {
                                this.addScore(10);
                                this.lastY = this.y;
                                this.increaseCombo();
                            }
                        }
                        break;
                    case 'down':
                        if (this.y < canvas.height - this.height - 120) { // Leave more space at bottom for mobile controls
                            this.y += CELL_SIZE;
                            this.rotation = 0.2;
                            moved = true;
                        }
                        break;
                    case 'left':
                        if (this.x > 20) {
                            this.x -= CELL_SIZE;
                            this.rotation = -0.1;
                            moved = true;
                        }
                        break;
                    case 'right':
                        if (this.x < canvas.width - this.width - 20) {
                            this.x += CELL_SIZE;
                            this.rotation = 0.1;
                            moved = true;
                        }
                        break;
                }
                
                if (moved) {
                    this.isMoving = true;
                    this.moveAnimation = 1;
                    this.scale = 1.2;
                    playSound(jumpSound);
                    
                    // Create movement particles
                    this.createMoveParticles();
                    
                    // Achievement: First step
                    unlockAchievement('firstStep');
                }
                
                // Check if reached top (finish line)
                if (this.y <= FINISH_LINE) {
                    this.levelComplete();
                }
            }
            
            addScore(points) {
                const multiplier = Math.max(1, combo);
                const totalPoints = points * multiplier;
                score += totalPoints;
                
                // Create floating text
                floatingTexts.push(new FloatingText(
                    this.x + this.width/2, 
                    this.y, 
                    `+${totalPoints}`, 
                    '#00ffcc'
                ));
                
                updateUI();
                checkAchievements();
            }
            
            increaseCombo() {
                combo++;
                if (combo > 1) {
                    document.getElementById('comboDisplay').style.display = 'block';
                    document.getElementById('comboCount').textContent = combo;
                    
                    setTimeout(() => {
                        document.getElementById('comboDisplay').style.display = 'none';
                    }, 2000);
                }
                
                if (combo >= 5) {
                    unlockAchievement('comboMaster');
                }
            }
            
            levelComplete() {
                level++;
                gameStats.levelsCompleted++;
                this.addScore(100 * level);
                this.reset();
                cars = [];
                powerUps = [];
                combo = 0;
                
                // Show level up message
                document.getElementById('levelUpMessage').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('levelUpMessage').style.display = 'none';
                }, 3000);
                
                // Create celebration particles
                this.createCelebrationParticles();
                
                // Check for achievements
                if (level >= 5) unlockAchievement('survivor');
                if (gameStats.hitsTaken === 0) unlockAchievement('invincible');
                
                updateUI();
            }
            
            createMoveParticles() {
                for (let i = 0; i < 5; i++) {
                    particles.push(new Particle(
                        this.x + this.width/2 + (Math.random() - 0.5) * this.width,
                        this.y + this.height,
                        '#00ffcc',
                        Math.random() * 2 + 1
                    ));
                }
            }
            
            createCelebrationParticles() {
                for (let i = 0; i < 30; i++) {
                    particles.push(new Particle(
                        this.x + this.width/2,
                        this.y + this.height/2,
                        `hsl(${Math.random() * 360}, 100%, 50%)`,
                        Math.random() * 4 + 2
                    ));
                }
            }
            
            reset() {
                this.x = canvas.width / 2 - 30;
                this.y = canvas.height - 180; // Match new starting position
                this.lastY = this.y;
                this.rotation = 0;
                this.scale = 1;
            }
        }

        // Enhanced Car class
        class Car {
            constructor(lane, direction = 1) {
                this.width = 90;
                this.height = 50;
                this.y = lane - 25; // Center car on lane
                this.direction = direction;
                this.speed = DIFFICULTY_SETTINGS[difficulty].carSpeed * direction * (0.7 + Math.random() * 0.6);
                
                // Spawn cars further off screen for better flow
                if (direction === 1) {
                    this.x = -this.width - Math.random() * 300;
                } else {
                    this.x = canvas.width + Math.random() * 300;
                }
                
                this.carType = Math.floor(Math.random() * 4) + 1;
                this.color = this.getRandomColor();
                this.exhaustTimer = 0;
                this.hornTimer = Math.random() * 300; // Random horn timing
            }
            
            getRandomColor() {
                const colors = [
                    '#ff3333', '#3333ff', '#ffff33', '#ff33ff', 
                    '#33ffff', '#ff8800', '#8800ff', '#00ff88',
                    '#ff0088', '#88ff00', '#0088ff', '#ff8888'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            update() {
                this.x += this.speed;
                this.exhaustTimer++;
                this.hornTimer++;
                
                // Create enhanced exhaust particles
                if (this.exhaustTimer % 2 === 0) {
                    const exhaustX = this.direction === 1 ? this.x - 5 : this.x + this.width + 5;
                    const exhaustY = this.y + this.height/2 + (Math.random() - 0.5) * 15;
                    
                    particles.push(new Particle(
                        exhaustX + (Math.random() - 0.5) * 10,
                        exhaustY,
                        Math.random() > 0.5 ? '#666666' : '#444444',
                        Math.random() * 2 + 1
                    ));
                }
                
                // Occasional horn sound effect (visual)
                if (this.hornTimer > 400 && Math.random() < 0.002) {
                    floatingTexts.push(new FloatingText(
                        this.x + this.width/2,
                        this.y - 20,
                        '♪',
                        '#ffeb3b'
                    ));
                    this.hornTimer = 0;
                }
                
                // Remove cars that are way off screen
                if (this.direction === 1 && this.x > canvas.width + 300) {
                    return false;
                }
                if (this.direction === -1 && this.x < -this.width - 300) {
                    return false;
                }
                return true;
            }
            
            draw() {
                const imageName = `assets/car${this.carType}.png`;
                
                ctx.save();
                
                // Enhanced motion blur for fast cars
                if (Math.abs(this.speed) > 3) {
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = Math.abs(this.speed) * 2;
                    ctx.shadowOffsetX = -this.speed * 1.5;
                }
                
                if (images[imageName]) {
                    if (this.direction === -1) {
                        ctx.scale(-1, 1);
                        ctx.drawImage(images[imageName], -this.x - this.width, this.y, this.width, this.height);
                    } else {
                        ctx.drawImage(images[imageName], this.x, this.y, this.width, this.height);
                    }
                } else {
                    // Enhanced fallback with more details
                    const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
                    gradient.addColorStop(0, this.color);
                    gradient.addColorStop(0.3, this.lightenColor(this.color, 20));
                    gradient.addColorStop(0.7, this.color);
                    gradient.addColorStop(1, this.darkenColor(this.color, 30));
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    // Enhanced car details
                    // Windows
                    ctx.fillStyle = 'rgba(100, 150, 200, 0.8)';
                    const windowY = this.y + 8;
                    const windowHeight = 15;
                    ctx.fillRect(this.x + 15, windowY, 25, windowHeight);
                    ctx.fillRect(this.x + 50, windowY, 25, windowHeight);
                    
                    // Headlights/taillights with glow
                    const isHeadlight = this.direction === 1;
                    ctx.fillStyle = isHeadlight ? '#ffff99' : '#ff4444';
                    ctx.shadowColor = isHeadlight ? '#ffff99' : '#ff4444';
                    ctx.shadowBlur = 8;
                    
                    const lightX = isHeadlight ? this.x + this.width - 8 : this.x + 3;
                    ctx.fillRect(lightX, this.y + 8, 5, 8);
                    ctx.fillRect(lightX, this.y + 34, 5, 8);
                    
                    // Wheels
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.arc(this.x + 15, this.y + this.height + 2, 8, 0, Math.PI * 2);
                    ctx.arc(this.x + this.width - 15, this.y + this.height + 2, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            lightenColor(color, percent) {
                const num = parseInt(color.replace("#",""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + 
                    (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
            }
            
            darkenColor(color, percent) {
                const num = parseInt(color.replace("#",""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) - amt;
                const G = (num >> 8 & 0x00FF) - amt;
                const B = (num & 0x0000FF) - amt;
                return "#" + (0x1000000 + (R>0?R:0)*0x10000 + 
                    (G>0?G:0)*0x100 + (B>0?B:0)).toString(16).slice(1);
            }
            
            getBounds() {
                return {
                    x: this.x + 5,
                    y: this.y + 5,
                    width: this.width - 10,
                    height: this.height - 10
                };
            }
        }

        // Enhanced Particle class
        class Particle {
            constructor(x, y, color = '#ff6b6b', size = 2) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8 - 2;
                this.life = 120;
                this.maxLife = 120;
                this.color = color;
                this.size = size;
                this.gravity = 0.1;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life--;
                this.size *= 0.99;
                this.rotation += this.rotationSpeed;
                this.vx *= 0.99;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.restore();
            }
            
            isDead() {
                return this.life <= 0 || this.size < 0.1;
            }
        }

        // Power-up class
        class PowerUp {
            constructor(x, y, type = 'invincibility') {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.type = type;
                this.bobTimer = 0;
                this.collected = false;
                this.glowIntensity = 0;
            }
            
            update() {
                this.bobTimer += 0.1;
                this.glowIntensity = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
            }
            
            draw() {
                const bobOffset = Math.sin(this.bobTimer) * 5;
                
                ctx.save();
                ctx.shadowColor = this.getColor();
                ctx.shadowBlur = 15 + this.glowIntensity * 10;
                
                ctx.fillStyle = this.getColor();
                ctx.fillRect(this.x, this.y + bobOffset, this.width, this.height);
                
                // Draw power-up symbol
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.getSymbol(), this.x + this.width/2, this.y + this.height/2 + bobOffset + 8);
                
                ctx.restore();
            }
            
            getColor() {
                switch(this.type) {
                    case 'invincibility': return '#ff6b6b';
                    case 'points': return '#ffa500';
                    case 'life': return '#00ff00';
                    default: return '#ff6b6b';
                }
            }
            
            getSymbol() {
                switch(this.type) {
                    case 'invincibility': return '⚡';
                    case 'points': return '💎';
                    case 'life': return '❤️';
                    default: return '⚡';
                }
            }
            
            getBounds() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
        }

        // Floating text class
        class FloatingText {
            constructor(x, y, text, color = '#fff') {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.life = 120;
                this.maxLife = 120;
                this.vy = -2;
                this.size = 20;
            }
            
            update() {
                this.y += this.vy;
                this.life--;
                this.size *= 1.01;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.font = `bold ${this.size}px Orbitron`;
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(this.text, this.x, this.y);
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }
            
            isDead() {
                return this.life <= 0;
            }
        }

        // Initialize game
        function init() {
            player = new Player();
            loadImages();
            updateUI();
            loadAchievements();
            createFloatingParticles();
        }
        
        function loadImages() {
            imageFiles.forEach(filename => {
                const img = new Image();
                img.onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === imageFiles.length) {
                        console.log('All images loaded');
                    }
                };
                img.onerror = () => {
                    console.warn(`Failed to load ${filename}`);
                    imagesLoaded++;
                };
                img.src = filename;
                images[filename] = img;
            });
        }
        
        function createFloatingParticles() {
            // Create floating background particles
            for (let i = 0; i < 5; i++) {
                const particle = document.createElement('div');
                particle.className = 'floating-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 3 + 's';
                particle.style.animationDuration = (3 + Math.random() * 2) + 's';
                document.body.appendChild(particle);
            }
        }
        
        // Enhanced game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        function update() {
            if (gameState !== 'playing') return;
            
            // Update invincibility
            if (isInvincible) {
                invincibilityTimer--;
                if (invincibilityTimer <= 0) {
                    isInvincible = false;
                    document.getElementById('powerUpIndicator').style.display = 'none';
                }
            }
            
            // Update cars
            cars = cars.filter(car => car.update());
            
            // Update power-ups
            powerUps.forEach(powerUp => powerUp.update());
            
            // Update particles
            particles = particles.filter(particle => {
                particle.update();
                return !particle.isDead();
            });
            
            // Update floating texts
            floatingTexts = floatingTexts.filter(text => {
                text.update();
                return !text.isDead();
            });
            
            // Spawn new cars
            spawnCars();
            
            // Spawn power-ups occasionally
            spawnPowerUps();
            
            // Check collisions
            checkCollisions();
            checkPowerUpCollisions();
        }
        
        function draw() {
            // Clear canvas with gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.15, '#4682B4');
            gradient.addColorStop(0.85, '#2F4F4F');
            gradient.addColorStop(1, '#1a3a1a');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw enhanced background elements
            drawEnhancedBackground();
            
            if (gameState === 'playing' || gameState === 'paused') {
                // Draw game objects
                player.draw();
                cars.forEach(car => car.draw());
                powerUps.forEach(powerUp => powerUp.draw());
                particles.forEach(particle => particle.draw());
                floatingTexts.forEach(text => text.draw());
                
                // Draw screen shake effect if recent collision
                if (gameState === 'playing' && Math.random() < 0.1) {
                    drawScreenEffects();
                }
            }
        }
        
        function drawEnhancedBackground() {
            // REDESIGNED MAP LAYOUT - No water, cleaner design
            
            // TOP SAFE ZONE - Finish area with celebration
            const finishGradient = ctx.createLinearGradient(0, 0, 0, 180);
            finishGradient.addColorStop(0, '#4CAF50');
            finishGradient.addColorStop(0.3, '#2E7D32');
            finishGradient.addColorStop(0.7, '#1B5E20');
            finishGradient.addColorStop(1, '#0D4015');
            
            ctx.fillStyle = finishGradient;
            ctx.fillRect(0, 0, canvas.width, 180);
            
            // Add finish line pattern
            ctx.fillStyle = '#fff';
            for (let x = 0; x < canvas.width; x += 40) {
                for (let i = 0; i < 3; i++) {
                    if ((x / 40 + i) % 2 === 0) {
                        ctx.fillRect(x, 150 + i * 10, 20, 10);
                    }
                }
            }
            
            // Add victory flags
            ctx.fillStyle = '#ff6b6b';
            for (let x = 100; x < canvas.width; x += 200) {
                // Flag pole
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x, 30, 4, 80);
                
                // Flag
                ctx.fillStyle = level % 2 === 0 ? '#ff6b6b' : '#4ecdc4';
                ctx.fillRect(x + 4, 30, 30, 20);
                
                // Flag details
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.fillText('★', x + 12, 44);
            }
            
            // Add grass texture to finish area
            ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
            for (let x = 0; x < canvas.width; x += 20) {
                for (let y = 0; y < 150; y += 20) {
                    if (Math.random() > 0.6) {
                        ctx.fillRect(x + Math.random() * 15, y + Math.random() * 15, 2, 8);
                    }
                }
            }
            
            // MIDDLE SAFE ZONE - Rest area between road sections
            const middleGradient = ctx.createLinearGradient(0, 180, 0, 200);
            middleGradient.addColorStop(0, '#795548');
            middleGradient.addColorStop(0.5, '#5D4037');
            middleGradient.addColorStop(1, '#3E2723');
            
            ctx.fillStyle = middleGradient;
            ctx.fillRect(0, 180, canvas.width, 20);
            
            // Add sidewalk pattern
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 30) {
                ctx.beginPath();
                ctx.moveTo(x, 180);
                ctx.lineTo(x, 200);
                ctx.stroke();
            }
            
            // MAIN ROAD SECTION - Enhanced with multiple layers
            const roadGradient = ctx.createLinearGradient(0, 200, 0, 680);
            roadGradient.addColorStop(0, '#2a2a2a');
            roadGradient.addColorStop(0.1, '#1a1a1a');
            roadGradient.addColorStop(0.2, '#404040');
            roadGradient.addColorStop(0.3, '#353535');
            roadGradient.addColorStop(0.4, '#2a2a2a');
            roadGradient.addColorStop(0.5, '#404040');
            roadGradient.addColorStop(0.6, '#2a2a2a');
            roadGradient.addColorStop(0.7, '#353535');
            roadGradient.addColorStop(0.8, '#404040');
            roadGradient.addColorStop(0.9, '#1a1a1a');
            roadGradient.addColorStop(1, '#2a2a2a');
            
            ctx.fillStyle = roadGradient;
            ctx.fillRect(0, 200, canvas.width, 480);
            
            // Add detailed road texture
            ctx.save();
            ctx.globalAlpha = 0.15;
            ctx.fillStyle = '#111';
            
            // Tire marks and road wear
            for (let i = 0; i < 60; i++) {
                const x = Math.random() * canvas.width;
                const y = 210 + Math.random() * 460;
                const width = 40 + Math.random() * 60;
                const height = 2 + Math.random() * 3;
                ctx.fillRect(x, y, width, height);
            }
            
            // Oil stains and road imperfections
            ctx.fillStyle = '#0a0a0a';
            for (let i = 0; i < 25; i++) {
                const x = Math.random() * canvas.width;
                const y = 210 + Math.random() * 460;
                ctx.beginPath();
                ctx.arc(x, y, 3 + Math.random() * 12, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            // Road shoulders and edges
            const shoulderGradient = ctx.createLinearGradient(0, 200, 0, 210);
            shoulderGradient.addColorStop(0, '#666');
            shoulderGradient.addColorStop(1, '#333');
            
            ctx.fillStyle = shoulderGradient;
            ctx.fillRect(0, 200, canvas.width, 10); // Top shoulder
            ctx.fillRect(0, 670, canvas.width, 10); // Bottom shoulder
            
            // ENHANCED LANE MARKERS with realistic highway appearance
            ctx.save();
            
            // Outer lane lines (solid yellow) - Highway standard
            ctx.strokeStyle = '#ffeb3b';
            ctx.lineWidth = 6;
            ctx.shadowColor = '#ffeb3b';
            ctx.shadowBlur = 8;
            
            // Top edge line
            ctx.beginPath();
            ctx.moveTo(0, 215);
            ctx.lineTo(canvas.width, 215);
            ctx.stroke();
            
            // Bottom edge line
            ctx.beginPath();
            ctx.moveTo(0, 665);
            ctx.lineTo(canvas.width, 665);
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            
            // Inner lane dividers (dashed white with realistic animation)
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 6;
            
            const dashLength = 40;
            const gapLength = 30;
            const animationOffset = (Date.now() * 0.15) % (dashLength + gapLength);
            
            // Draw dashed lines for each lane division
            for (let i = 1; i < ROAD_LANES.length; i++) {
                const prevLane = ROAD_LANES[i-1];
                const currentLane = ROAD_LANES[i];
                const lineY = (prevLane + currentLane) / 2;
                
                ctx.beginPath();
                for (let x = -animationOffset; x < canvas.width + dashLength; x += dashLength + gapLength) {
                    if (x + dashLength > 0 && x < canvas.width) {
                        ctx.moveTo(Math.max(0, x), lineY);
                        ctx.lineTo(Math.min(canvas.width, x + dashLength), lineY);
                    }
                }
                ctx.stroke();
            }
            
            ctx.restore();
            
            // Add road reflectors (cat's eyes) for realism
            ctx.fillStyle = '#ffeb3b';
            ctx.shadowColor = '#ffeb3b';
            ctx.shadowBlur = 4;
            
            for (let i = 1; i < ROAD_LANES.length; i++) {
                const prevLane = ROAD_LANES[i-1];
                const currentLane = ROAD_LANES[i];
                const lineY = (prevLane + currentLane) / 2;
                
                for (let x = 60; x < canvas.width; x += 140) {
                    ctx.beginPath();
                    ctx.arc(x, lineY, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add reflector glow
                    ctx.beginPath();
                    ctx.arc(x, lineY, 1, 0, Math.PI * 2);
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                    ctx.fillStyle = '#ffeb3b';
                }
            }
            
            ctx.shadowBlur = 0;
            
            // BOTTOM SAFE ZONE - Starting area with enhanced design (expanded for mobile)
            const startGradient = ctx.createLinearGradient(0, 680, 0, canvas.height);
            startGradient.addColorStop(0, '#4a7c59');
            startGradient.addColorStop(0.3, '#2d5a27');
            startGradient.addColorStop(0.7, '#1a4a1a');
            startGradient.addColorStop(1, '#0d3d0d');
            
            ctx.fillStyle = startGradient;
            ctx.fillRect(0, 680, canvas.width, canvas.height - 680);
            
            // Add starting area decorations with better spacing for mobile
            ctx.fillStyle = 'rgba(45, 90, 39, 0.4)';
            for (let x = 0; x < canvas.width; x += 25) {
                for (let y = 690; y < canvas.height - 160; y += 25) { // Leave space for mobile controls
                    if (Math.random() > 0.5) {
                        ctx.fillRect(x + Math.random() * 20, y + Math.random() * 20, 3, 12);
                    }
                }
            }
            
            // Add some flowers and bushes in starting area (positioned higher for mobile)
            for (let x = 80; x < canvas.width - 80; x += 120) {
                // Bush
                ctx.fillStyle = '#2d5a27';
                ctx.beginPath();
                ctx.arc(x, canvas.height - 220, 20, 0, Math.PI * 2); // Moved higher
                ctx.fill();
                
                // Flowers
                const flowerColors = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#ff8b94'];
                for (let i = 0; i < 3; i++) {
                    ctx.fillStyle = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                    ctx.beginPath();
                    ctx.arc(x + (i - 1) * 15, canvas.height - 240, 4, 0, Math.PI * 2); // Moved higher
                    ctx.fill();
                }
            }
            
            // Add level indicators in starting area (positioned for mobile)
            if (level > 1) {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(`LEVEL ${level}`, canvas.width / 2, canvas.height - 190); // Moved higher
                
                // Level progress bar
                const progressWidth = 200;
                const progressX = (canvas.width - progressWidth) / 2;
                const progressY = canvas.height - 210; // Moved higher
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(progressX, progressY, progressWidth, 8);
                
                const progress = Math.min(score / (level * 100), 1);
                const fillGradient = ctx.createLinearGradient(progressX, progressY, progressX + progressWidth, progressY);
                fillGradient.addColorStop(0, '#4ecdc4');
                fillGradient.addColorStop(1, '#00ffcc');
                
                ctx.fillStyle = fillGradient;
                ctx.fillRect(progressX, progressY, progressWidth * progress, 8);
            }
            
            // Add road signs and highway elements for immersion
            if (level > 2) {
                // Highway signs
                ctx.fillStyle = '#2E7D32';
                ctx.fillRect(canvas.width - 80, 160, 70, 30);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('EXIT', canvas.width - 45, 175);
                ctx.fillText(`LVL ${level}`, canvas.width - 45, 185);
            }
        }
        
        function drawScreenEffects() {
            // Add subtle screen effects
            const time = Date.now() * 0.001;
            
            // Scanlines effect
            ctx.strokeStyle = 'rgba(0, 255, 204, 0.02)';
            ctx.lineWidth = 1;
            for (let y = 0; y < canvas.height; y += 4) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        function spawnCars() {
            const settings = DIFFICULTY_SETTINGS[difficulty];
            
            // More aggressive spawning
            if (cars.length < settings.maxCars && Math.random() < settings.spawnRate) {
                const laneIndex = Math.floor(Math.random() * ROAD_LANES.length);
                const lane = ROAD_LANES[laneIndex];
                const direction = laneIndex % 2 === 0 ? 1 : -1;
                
                // Less restrictive lane checking
                const laneHasCar = cars.some(car => 
                    Math.abs(car.y - lane) < 30 && 
                    ((direction === 1 && car.x > -80 && car.x < 150) ||
                     (direction === -1 && car.x < canvas.width + 80 && car.x > canvas.width - 150))
                );
                
                if (!laneHasCar) {
                    cars.push(new Car(lane, direction));
                }
            }
            
            // Force spawn cars if none exist (guaranteed traffic!)
            if (cars.length === 0) {
                const laneIndex = Math.floor(Math.random() * ROAD_LANES.length);
                const lane = ROAD_LANES[laneIndex];
                const direction = laneIndex % 2 === 0 ? 1 : -1;
                cars.push(new Car(lane, direction));
            }
            
            // Occasionally spawn multiple cars for challenge
            if (Math.random() < 0.03 && cars.length < settings.maxCars - 2) {
                for (let i = 0; i < 2; i++) {
                    const laneIndex = Math.floor(Math.random() * ROAD_LANES.length);
                    const lane = ROAD_LANES[laneIndex];
                    const direction = laneIndex % 2 === 0 ? 1 : -1;
                    
                    const laneHasCar = cars.some(car => 
                        Math.abs(car.y - lane) < 30 && 
                        ((direction === 1 && car.x > -80 && car.x < 100) ||
                         (direction === -1 && car.x < canvas.width + 80 && car.x > canvas.width - 100))
                    );
                    
                    if (!laneHasCar) {
                        cars.push(new Car(lane, direction));
                    }
                }
            }
        }
        
        function spawnPowerUps() {
            const settings = DIFFICULTY_SETTINGS[difficulty];
            
            if (powerUps.length < 2 && Math.random() < settings.powerUpChance * 0.1) {
                const types = ['invincibility', 'points', 'life'];
                const type = types[Math.floor(Math.random() * types.length)];
                const x = Math.random() * (canvas.width - 40);
                
                // Spawn in safe zones only - top finish area or bottom starting area (mobile-friendly)
                const safeAreas = [80, canvas.height - 240]; // Top and higher bottom safe zone
                const y = safeAreas[Math.floor(Math.random() * safeAreas.length)];
                
                powerUps.push(new PowerUp(x, y, type));
            }
        }
        
        function checkCollisions() {
            if (isInvincible) return;
            
            const playerBounds = {
                x: player.x + 10,
                y: player.y + 10,
                width: player.width - 20,
                height: player.height - 20
            };
            
            for (let car of cars) {
                const carBounds = car.getBounds();
                
                if (playerBounds.x < carBounds.x + carBounds.width &&
                    playerBounds.x + playerBounds.width > carBounds.x &&
                    playerBounds.y < carBounds.y + carBounds.height &&
                    playerBounds.y + playerBounds.height > carBounds.y) {
                    
                    createExplosion(player.x + player.width/2, player.y + player.height/2);
                    playSound(crashSound);
                    loseLife();
                    screenShake();
                    combo = 0;
                    gameStats.hitsTaken++;
                    break;
                }
            }
        }
        
        function checkPowerUpCollisions() {
            const playerBounds = {
                x: player.x,
                y: player.y,
                width: player.width,
                height: player.height
            };
            
            powerUps = powerUps.filter(powerUp => {
                const powerUpBounds = powerUp.getBounds();
                
                if (playerBounds.x < powerUpBounds.x + powerUpBounds.width &&
                    playerBounds.x + playerBounds.width > powerUpBounds.x &&
                    playerBounds.y < powerUpBounds.y + powerUpBounds.height &&
                    playerBounds.y + playerBounds.height > powerUpBounds.y) {
                    
                    // Collect power-up
                    collectPowerUp(powerUp);
                    return false;
                }
                return true;
            });
        }
        
        function collectPowerUp(powerUp) {
            gameStats.powerUpsCollected++;
            
            switch(powerUp.type) {
                case 'invincibility':
                    isInvincible = true;
                    invincibilityTimer = 300; // 5 seconds at 60fps
                    document.getElementById('powerUpIndicator').style.display = 'block';
                    break;
                case 'points':
                    player.addScore(50);
                    break;
                case 'life':
                    if (lives < 5) {
                        lives++;
                        updateUI();
                    }
                    break;
            }
            
            // Create collection effect
            for (let i = 0; i < 15; i++) {
                particles.push(new Particle(
                    powerUp.x + powerUp.width/2,
                    powerUp.y + powerUp.height/2,
                    powerUp.getColor(),
                    Math.random() * 3 + 2
                ));
            }
            
            floatingTexts.push(new FloatingText(
                powerUp.x + powerUp.width/2,
                powerUp.y,
                powerUp.getSymbol(),
                powerUp.getColor()
            ));
            
            if (gameStats.powerUpsCollected >= 10) {
                unlockAchievement('powerUser');
            }
        }
        
        function createExplosion(x, y) {
            for (let i = 0; i < 40; i++) {
                particles.push(new Particle(
                    x + (Math.random() - 0.5) * 40,
                    y + (Math.random() - 0.5) * 40,
                    `hsl(${Math.random() * 60}, 100%, ${50 + Math.random() * 50}%)`,
                    Math.random() * 6 + 2
                ));
            }
        }
        
        function screenShake() {
            document.getElementById('gameContainer').classList.add('screen-shake');
            setTimeout(() => {
                document.getElementById('gameContainer').classList.remove('screen-shake');
            }, 500);
        }
        
        function loseLife() {
            lives--;
            updateUI();
            
            if (lives <= 0) {
                gameOver();
            } else {
                player.reset();
                // Brief invincibility period
                isInvincible = true;
                invincibilityTimer = 120;
            }
        }
        
        function gameOver() {
            gameState = 'gameOver';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('highScore').textContent = highScore;
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('nitroFrogHighScore', highScore);
                document.getElementById('highScore').textContent = highScore;
            }
            
            // Check final achievements
            if (score >= 100) unlockAchievement('scorer');
            if (score >= 1000) unlockAchievement('roadWarrior');
            
            document.getElementById('gameOverScreen').style.display = 'flex';
            loadLeaderboard();
        }
        
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('levelDisplay').textContent = level;
        }
        
        function playSound(audio) {
            try {
                audio.currentTime = 0;
                audio.play().catch(e => console.log('Audio play failed:', e));
            } catch (e) {
                console.log('Audio error:', e);
            }
        }
        
        // Achievement system
        function unlockAchievement(achievementId) {
            if (!achievements[achievementId].unlocked) {
                achievements[achievementId].unlocked = true;
                saveAchievements();
                
                // Show achievement notification
                floatingTexts.push(new FloatingText(
                    canvas.width / 2,
                    canvas.height / 2,
                    `🎖️ ${achievements[achievementId].name}`,
                    '#ffa500'
                ));
            }
        }
        
        function checkAchievements() {
            if (score >= 100 && !achievements.scorer.unlocked) {
                unlockAchievement('scorer');
            }
            if (score >= 1000 && !achievements.roadWarrior.unlocked) {
                unlockAchievement('roadWarrior');
            }
        }
        
        function saveAchievements() {
            localStorage.setItem('nitroFrogAchievements', JSON.stringify(achievements));
        }
        
        function loadAchievements() {
            const saved = localStorage.getItem('nitroFrogAchievements');
            if (saved) {
                const savedAchievements = JSON.parse(saved);
                for (let key in savedAchievements) {
                    if (achievements[key]) {
                        achievements[key].unlocked = savedAchievements[key].unlocked;
                    }
                }
            }
        }
        
        // Game control functions
        function startGame() {
            difficulty = document.getElementById('difficulty').value;
            document.getElementById('startScreen').style.display = 'none';
            resetGame();
            gameState = 'playing';
            gameStats.gameStartTime = Date.now();
        }
        
        function resetGame() {
            score = 0;
            lives = 3;
            level = 1;
            combo = 0;
            isInvincible = false;
            invincibilityTimer = 0;
            cars = [];
            particles = [];
            powerUps = [];
            floatingTexts = [];
            gameStats = {
                powerUpsCollected: 0,
                levelsCompleted: 0,
                gameStartTime: Date.now(),
                hitsTaken: 0
            };
            player.reset();
            updateUI();
        }
        
        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            resetGame();
            gameState = 'playing';
        }
        
        function pauseGame() {
            if (gameState === 'playing') {
                gameState = 'paused';
                document.getElementById('pauseScreen').style.display = 'flex';
            }
        }
        
        function resumeGame() {
            if (gameState === 'paused') {
                gameState = 'playing';
                document.getElementById('pauseScreen').style.display = 'none';
            }
        }
        
        function togglePause() {
            if (gameState === 'playing') {
                pauseGame();
            } else if (gameState === 'paused') {
                resumeGame();
            }
        }
        
        function goToMenu() {
            gameState = 'menu';
            document.getElementById('startScreen').style.display = 'flex';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('achievementScreen').style.display = 'none';
        }
        
        function showAchievements() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('achievementScreen').style.display = 'flex';
            
            const grid = document.getElementById('achievementGrid');
            grid.innerHTML = '';
            
            for (let key in achievements) {
                const achievement = achievements[key];
                const item = document.createElement('div');
                item.className = `achievement-item ${achievement.unlocked ? 'unlocked' : ''}`;
                item.innerHTML = `
                    <div style="font-size: 24px; margin-bottom: 5px;">
                        ${achievement.unlocked ? '🏆' : '🔒'}
                    </div>
                    <div style="font-weight: bold; font-size: 12px;">${achievement.name}</div>
                    <div style="font-size: 10px; margin-top: 5px;">${achievement.desc}</div>
                `;
                grid.appendChild(item);
            }
        }
        
        function showLeaderboard() {
            loadLeaderboard();
        }
        
        // Leaderboard functions
        async function submitScore() {
            const playerName = document.getElementById('playerName').value.trim() || 'Anonymous';
            
            try {
                const response = await fetch('https://distinguished-heart.up.railway.app/submit', {

                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        username: playerName,
                        score: score,
                        difficulty: difficulty
                    })
                });
                
                if (response.ok) {
                    loadLeaderboard();
                    document.getElementById('nameInput').style.display = 'none';
                }
            } catch (error) {
                console.error('Failed to submit score:', error);
                showLocalLeaderboard();
            }
        }
        
        async function loadLeaderboard() {
            try {
                const response = await fetch('https://distinguished-heart.up.railway.app/submit', {

                const leaderboard = await response.json();
                displayLeaderboard(leaderboard);
            } catch (error) {
                console.error('Failed to load leaderboard:', error);
                showLocalLeaderboard();
            }
        }
        
        function showLocalLeaderboard() {
            const localScores = JSON.parse(localStorage.getItem('nitroFrogScores') || '[]');
            displayLeaderboard(localScores);
        }
        
        function displayLeaderboard(scores) {
            const leaderboardDiv = document.getElementById('leaderboard');
            
            if (scores.length === 0) {
                leaderboardDiv.innerHTML = '<h3>🏆 HALL OF FAME</h3><p>No legends yet!</p>';
                return;
            }
            
            let html = '<h3>🏆 HALL OF FAME</h3>';
            scores.slice(0, 10).forEach((entry, index) => {
                const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`;
                html += `
                    <div class="leaderboard-entry">
                        <span>${medal} ${entry.username}</span>
                        <span>${entry.score} (${entry.difficulty})</span>
                    </div>
                `;
            });
            
            leaderboardDiv.innerHTML = html;
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    player.move('up');
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    player.move('down');
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    player.move('left');
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    player.move('right');
                    break;
                case ' ':
                    e.preventDefault();
                    togglePause();
                    break;
                case 'Escape':
                    e.preventDefault();
                    if (gameState === 'playing' || gameState === 'paused') {
                        goToMenu();
                    }
                    break;
            }
        });
        
        // Enhanced touch controls for mobile
        let touchStartX, touchStartY;
        let lastTouchTime = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchStartY = touch.clientY - rect.top;
            lastTouchTime = Date.now();
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const touchEndX = touch.clientX - rect.left;
            const touchEndY = touch.clientY - rect.top;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const touchDuration = Date.now() - lastTouchTime;
            const minSwipeDistance = 30;
            
            // Quick tap for immediate response
            if (touchDuration < 200 && Math.abs(deltaX) < 20 && Math.abs(deltaY) < 20) {
                // Quick tap - move up by default
                player.move('up');
                return;
            }
            
            // Swipe gestures
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                if (deltaX > 0) {
                    player.move('right');
                } else {
                    player.move('left');
                }
            } else if (Math.abs(deltaY) > minSwipeDistance) {
                if (deltaY > 0) {
                    player.move('down');
                } else {
                    player.move('up');
                }
            }
        });
        
        // Enhanced mobile control buttons with haptic feedback
        function movePlayer(direction) {
            player.move(direction);
            
            // Simulate haptic feedback with visual feedback
            const btn = document.querySelector(`.control-btn.${direction}`);
            if (btn) {
                btn.style.transform = 'scale(0.8)';
                setTimeout(() => {
                    btn.style.transform = '';
                }, 100);
            }
        }
        
        // Add touch event listeners to control buttons for better responsiveness
        document.addEventListener('DOMContentLoaded', () => {
            const controlButtons = document.querySelectorAll('.control-btn');
            controlButtons.forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    btn.style.transform = 'scale(0.85)';
                });
                
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    btn.style.transform = '';
                });
            });
        });
        
        // Initialize and start game loop
        init();
        gameLoop();
    </script>
</body>
</html>
